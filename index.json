[{"categories":["emacs"],"content":"1 ChatGPT介绍 ChatGPT是一种基于GPT-3.5模型的聊天机器人，它可以通过自然语言与用户进行交互，提供有趣的对话体验。本质是基于深度学习的自然语言处理模型，可以生成高质量的自然语言文本。 前些日子, OpenAI 在官网开放了 ChatGPT API, 基于\"gpt-3.5 - turbo\" 模型, 比之前的网页版多了一些内容准确性和逻辑性的改进. 在定价上, OpenAI 每1000 个 token 0.002 美元, 可谓十分低廉. 而在 emacs 中集成 chatgpt 的最大优势在于可以有效利用 emacs 的高拓展性实现自己的定制需求, 方便整合信息进入我们的工作流中. 这里使用 manateelazycat 大佬开发的 mind-wave , 其一大优点在于将当前的所有对话均保存在一个buffer中, 后续可以随时继续访问这个buffer 对应文件获取之前的对话内容, 同时还封装了很多便捷的指令, 非常推荐. ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:1:0","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"2 ChatGPT 注册 本文的重点在于和 emacs 的配合, 因此如何注册可参考这篇文章, 这里仅做一些简单说明 https://juejin.cn/post/7199657558834692157 ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:2:0","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"2.1 准备条件 能通过代理科学上网, 可以尝试诸如 naiveproxy, v2ray 和 Shadowsocks 等方法通过浏览器访问 openai 的官网. 最好有一张国外信用卡, 国内发行的 visa 或者全币种卡不行, 可以使用一些其他虚拟方案. 如果你是 linux 系统, 可以使用 proxychains 等工具在命令行启用代理, 也可以直接使用如下方法( 这里假设你的 listening 是 0.0.0.0, port 是8888 和 8889): export socks_proxy=socks5://0.0.0.0:8888 export http_proxy=http://0.0.0.0:8889 export https_proxy=http://0.0.0.0:8889 ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:2:1","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"2.2 国外手机号 注册需要一个国外手机号, 如果你已经有了, 请跳过本节. 在 sms-activate.org 网站注册一个账号并登录，默认是使用邮箱注册的。 点击网站右上角的充值按钮，进入充值页面，目前最低充值 2 美元。 回到网站首页，在左侧搜索栏直接搜索 openai 虚拟手机号注册服务，可以随便选择一个国家号码，复制手机号码去 openai 官网注册服务。 ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:2:2","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"2.3 注册 openai 点击官网链接，按照提示的流程往下输入信息, 其中手机验证阶段输入前面购买的虚拟手机号用来接收验证码即可。 ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:2:3","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"2.4 获取API 点击右上角View API keys—\u003e Create new secret key，可以生成API, 后续会用于 emacs 中使用。需要注意的是，出于安全原因，这个API只展示一次，请务必在关闭对话框之前，将其复制到你其他的地方保管 ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:2:4","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"3 在emacs 中集成ChatGPT 首先是一些准备工作. 安装依赖：pip3 install openai epc sexpdata six 下载 mind-wave: git clone https://github.com/manateelazycat/mind-wave.git. 将OpenAI API Key保存到 mind-wave-api-key-path 所指向的文件中, 它的默认值是 ~/.emacs.d/mind-wave/chatgpt_api_key.txt. 接着在 emacs 中对 mind-wave 进行简单配置: (add-to-list 'load-path \"/path/to/mind-wave\") (autoload #'mind-wave-chat-mode \"mind-wave\" nil t) 最后打开任意文件, 也可新建一个\"new_chats.chat\" 文件, 然后 M-x 调用 mind-wave-chat-mode 即可. ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:3:0","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["emacs"],"content":"4 常见使用方法与效果展示 执行命令 mind-wave-chat-ask（按下 Ctrl + j），输入问题，等待 ChatGPT 回答 执行命令 mind-wave-chat-continue (按下 Ctrl + u), 继续回答 执行命令 mind-wave-chat-generate-title (按下 Ctrl + i), 根据内容重新生成标题 如果更换话题，则换一个文件，然后继续向 ChatGPT 提问即可. mind-wave 还封装了诸如翻译内容, 根据视频链接动态生成视频摘要, 根据网页链接生成网页概要等功能. 这些都十分有趣, 篇幅限制不多介绍, 欢迎大家自行探索. 下面展示一个提问 “请分析和预测一下中国足球何时能出线” ","date":"2023-03-20","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/:4:0","tags":["chatgpt"],"title":"在emacs中集成和使用chatgpt","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs%E4%B8%AD%E9%9B%86%E6%88%90chatgpt/"},{"categories":["异构计算"],"content":"1 背景 随着计算机技术的不断发展，异构计算平台已经成为了一种趋势。异构计算平台由不同类型的处理器组成，例如CPU、GPU、FPGA等，这些处理器具有不同的特点和优势，可以在不同的应用场景中发挥作用, 利用不同类型的处理器来处理不同类型的计算任务，从而提高系统的性能。例如，CPU适合处理串行计算任务，而GPU适合处理并行计算任务. 但是，如何有效地调度这些处理器，使得整个系统的性能最优，是一个非常重要的问题。 ","date":"2023-03-18","objectID":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/:1:0","tags":null,"title":"  浅谈异构平台基于图计算结构的动静态调度方案(一)–\"导言\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/"},{"categories":["异构计算"],"content":"2 图结构 在异构计算平台中，计算图结构是一种常见的表示方法。计算图结构是一种有向无环图（DAG），其中每个节点表示一个计算任务，每条边表示任务之间的依赖关系。基于异构计算平台的计算图结构，可以设计出不同的计算方案。 有向无环图是一个比较成熟的领域. 在图论中，如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。 因为有向图中一个点经过两种路线到达另一个点未必形成环，因此有向无环图未必能转化成树，但任何有向树均为有向无环图。 基于计算图结构的异构计算平台具有以下主要特点： 高效性：异构计算平台可以利用不同类型的处理器来处理不同类型的计算任务，从而提高系统的性能。例如，CPU适合处理串行计算任务，而GPU适合处理并行计算任务的调度问题一直是一个难题。在异构计算平台中，可以根据任务的特点和系统的状态来选择最优的处理器来执行任务，从而提高系统的性能。 灵活性：基于计算图结构的异构计算平台可以根据任务的特点和系统的状态来动态地调整任务的分配方案，从而适应不同的应用场景。例如，可以根据处理器的负载情况、任务的优先级、任务的执行时间等因素来选择最优的处理器。 可扩展性：异构计算平台可以根据需要添加不同类型的处理器，从而扩展系统的计算能力。例如，可以添加GPU、FPGA等处理器来处理不同类型的计算任务。 ","date":"2023-03-18","objectID":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/:2:0","tags":null,"title":"  浅谈异构平台基于图计算结构的动静态调度方案(一)–\"导言\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/"},{"categories":["异构计算"],"content":"3 常见调度方案 在异构计算平台中，调度方案可以分为动态调度和静态调度两种。动态调度是指在运行时根据任务的需求和系统的状态来动态地分配任务到不同的处理器上。静态调度是指在编译时或者系统启动时就确定好任务的分配方案，然后在运行时按照预定的方案执行。 ","date":"2023-03-18","objectID":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/:3:0","tags":null,"title":"  浅谈异构平台基于图计算结构的动静态调度方案(一)–\"导言\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/"},{"categories":["异构计算"],"content":"3.1 动态调度 动态调度方案通常采用贪心算法或者启发式算法来实现。这些算法根据当前系统的状态和任务的需求，选择最优的处理器来执行任务。例如，可以根据处理器的负载情况、任务的优先级、任务的执行时间等因素来选择最优的处理器。动态调度方案的优点是可以根据实际情况来动态地调整任务的分配方案，从而提高系统的性能。但是，动态调度方案也存在一些缺点，例如调度算法的复杂度较高，容易出现死锁等问题。 ","date":"2023-03-18","objectID":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/:3:1","tags":null,"title":"  浅谈异构平台基于图计算结构的动静态调度方案(一)–\"导言\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/"},{"categories":["异构计算"],"content":"3.2 静态调度 静态调度方案通常采用图论算法来实现。这些算法可以在编译时或者系统启动时就确定好任务的分配方案，然后在运行时按照预定的方案执行。例如，可以使用拓扑排序算法来确定任务的执行顺序，然后根据处理器的特点和任务的需求来分配任务到不同的处理器上。静态调度方案的优点是可以在编译时或者系统启动时就确定好任务的分配方案，从而减少运行时的开销。但是，静态调度方案也存在一些缺点，例如无法适应动态的任务需求和系统状态变化。 综上所述，基于计算图结构的异构计算平台具有灵活性高、性能优越等特点。在实际应用中，可以根据任务的特点和系统的状态来选择最优的调度方案，从而提高系统的性能。静态调度方案和动态调度方案各有优缺点，可以根据实际情况选择最适合的方案。 接下来, 本文将进一步讲解主流调度方案的实现原理, 并分析各自的优点和局限性, 以及主要适用场景. ","date":"2023-03-18","objectID":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/:3:2","tags":null,"title":"  浅谈异构平台基于图计算结构的动静态调度方案(一)–\"导言\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%B5%85%E8%B0%88%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E5%9F%BA%E4%BA%8E%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9A%84%E5%8A%A8%E9%9D%99%E6%80%81%E8%B0%83%E5%BA%A6%E6%96%B9%E6%A1%88%E4%B8%80--%E5%AF%BC%E8%A8%80%E7%AF%87/"},{"categories":["emacs"],"content":"1 背景 ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:1:0","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"1.1 native-comp 前段时间 emacs 正式发布了 28.1, 其中一项重要特性就是合并了之前的 native-comp 分支( 俗称gccemacs). GCC Emacs 是一种利用 libgccjit 来编译 Elisp 的技术, 目标是提升 Emacs 以及 package 的启动速度和运行速度, 相比没有优化过的版本, 性能平均提高 3.7 倍. 我一直在使用 emacs 的测试版( 现在是emacs29 ), 因此对于 native-comp 也用了好几个月. 个人体验来讲, 除了编译时间比较长之外, 其他地方都很稳定, 而且使用起来也十分方便, 推荐大家在觉得性能有问题的时候进行尝试. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:1:1","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"1.2 Just-In-Time Compilation 关于什么是 GCC JIT, 引用官网的一小段话: GCC can be built as a shared library “libgccjit.so”, for generating machine code from API calls, using GCC as the backend. This shared library can then be dynamically-linked into bytecode interpreters and other such programs that want to generate machine code “on the fly” at run-time. 我尽量用简短的言语解释: 一个程序在它运行的时候创建并且运行了全新的代码, 并非那些最初作为这个程序的一部分保存在硬盘上的固有代码, 这就是所谓的 Just In Time. JIT 会把一些运行频繁的代码编译成本地机器相关的机器码, 这种直接执行机器指令能提高性能. JIT 还会进行一些编译优化, 比如逃逸分析, 锁消除, 类型检测消除, 方法内联等等, 从而提高速度. 上述是对 JIT 非常粗浅的介绍, GCC JIT 做的远不止这些, 感兴趣的小伙伴可以自行查阅. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:1:2","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"2 安装 ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:2:0","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"2.1 gcc jit环境 尝鲜的用户建议直接根据发行版安装 libgccjit 包以节省编译时间, 比如如果你是arch 用户, 可以直接 yay -S libgccjit-git 一键安装. 下面给出更为通用的本地编译方案: 首先 git clone 一个完整的 gcc 仓库, 推荐使用 github 上的 mirror 以获得更快的速度 git clone --depth=1 https://github.com/gcc-mirror/gcc.git 接着进行编译 mkdir build cd build ../src/configure --enable-host-shared --enable-languages=jit,c,c++,objc,obj-c++ --enable-checking=release --disable-bootstrap make -j12 make install ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:2:1","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"2.2 emacs 2.2.1 常规 接下来是 emacs 的安装, 同样推荐使用 github 上的 mirror: git clone --depth=1 https://github.com/emacs-mirror/emacs.git 接下来进行编译: ./autogen.sh ./configure --with-nativecomp make -j12 NATIVE_FULL_AOT=1 make install 注: 其中 NATIVE_FULL_AOT 是可选指令, 会强制把所有的 el 文件提前编译成 eln, 编译时间会大幅度增加, 如果你并不着急使用, 建议加上以节约后续使用的时间. 默认情况下, 在用户更新 package 或者修改代码后, emacs 会对这些有变动的文件进行重新编译. 2.2.2 mac 用户 如果你使用 mac 的话, 因为默认会使用 gcc 引起错误, 需要修改 configure 为: ./configure --with-nativecomp CC='clang' 其他步骤和之前一致. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:2:2","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"3 简单配置 在你的配置文件 init.el 中加入一些简单的优化: ;; Silence compiler warnings as they can be pretty disruptive (setq native-comp-async-report-warnings-errors nil) ;; Set the right directory to store the native comp cache (add-to-list 'native-comp-eln-load-path (expand-file-name \"eln-cache/\" user-emacs-directory)) ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:3:0","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":["emacs"],"content":"4 后言 至此, 已经完成了 emacs native comp 的安装. 当然, 在日常使用中用户不必关注和处理细节, 因为 emacs 会在后台自动地完成所有的编译和应用, 该过程会静默完成, 除了运行速度快了一些, 其他该怎么用还是怎么用. 个人而言, 对于编程体验特别是 lsp 的代码补全速度提升较大 Code on the fly ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/:4:0","tags":null,"title":"使用 Gcc Jit 为 emacs 加速","uri":"https://nowislewis.github.io/posts/gccemacs-%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"1 前言 对于经常使用计算机工作的人来将( 特别是程序员 ), 随着工作时间的推移和内容的延伸, 经常面临大量的文件需要管理的情况. 一个经常面临的问题是: 若果某个文件出现了异常, 如何快速方便地回退到之前的版本. 通常而言 office 和 git 等工具可以满足这些需求. 那么对于软件呢, 如果出现了 A 依赖 B , C 也依赖 B ，B 升级到新版 B1 ，假设 A 更新比较快也升级到 A1 ，但是 C 的开发比较慢，B1 下无法工作，这时怎么办？另一个更常见的问题是, A 依赖于B2, C 依赖于 B1, 彼此互不兼容, 虽然可以通过手动修改环境变量等方法可以绕开问题, 但比较混乱且治标不治本. 极端情况下，如果 B 是 linux 内核呢？ 在此, 我想介绍linux 上能一劳永逸解决这些问题的方案: Guix 或者 Nix. 本文会讨论不同 linux distro 的特点及在这个问题上的解决. 最后给出为什么我认为Guix 的解决方案是 真正省心和有效 的. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:1:0","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"2 Linux distribution 因个人倾向于实用性也就是快速解决实际问题, 所以在此不讨论UI 美观或者默认 package 等优化的问题, 仅讨论这些 dirstro 对于实际生产和生活的效率影响. 对大多数程序员来讲, 日常工作也就一个编辑器, 一个命令行,一个浏览器. 我个人也不喜欢在环境外观上花费太多时间, 仅在乎在生产和工作中的效率和实用性, 也就是 快速完成工作. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:2:0","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"2.1 Ubuntu 大家最熟悉的可能是 Ubuntu, 这套 Debian 系的distro, 易于安装易于部署, 作为生产环境而言稳定可靠. 我至今也仍有使用Debian 系的生产环境, 特别是其在驱动方面的广泛适配非常省心. 但作为个人工作电脑而言, Ubuntu 有着一些缺点, 比如系统版本升级麻烦, 包管理不方便等. 而且 Ubuntu 对于上述问题, 只能选择一个版本装, 不然会引起互相冲突. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:2:1","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"2.2 Arch 在多次遇到Ubuntu 著名的 “内部错误” 后, 我转向了 Archlinux, 一个滚动管理的 distro. 不得不说, archlinux 是一款从用户角度出发的系统, 极大地提升了工作和学习效率, 我使用了几年的 archlinux , 仍非常满意. 它有几个优点: 完全的滚动升级, 其持续的更新体验会让你始终使用最新的系统和软件包. 强大的社区基因. Arch wiki 可能是目前最强大 linux wiki 系统, 你遇到的绝大数linux 问题和知识都可以在这里获取, 不管你是否使用 arch, 这里都会大大帮助你的 linux 体验. 近乎全能的包管理. Aur 上拥有着近乎所有工作中可能需要的 package, 数量远比其他 dirtro 多. 通常情况下一条 yay -S package 就可以一键式安装你需要的 package 及其依赖, 非成省心. 当然, arch 也有一些缺点: 安装繁琐, arch 的安装不像 Ubuntu 等通过简单的图形化界面快速安装, 而是需要用户在命令行上输入大堆指令来推动系统的安装, 流程繁琐, 但保证了对系统的完全掌控. 滚动升级带来的环境不稳定性, 如果遇到这种情况往往需要手动处理, 这对用户的水平有一些要求. 但长期使用并没有遇到滚挂的情况. 回到版本依赖的问题上, Arch一般在打包过程时把产物文件重命名一下, 避免相互冲突, 然后依赖这个软件包的包在这个改好的PKGBUILD的基础上重新打包. 但如果件依赖十分复杂, 得自己重新打一堆包, 就特别麻烦. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:2:2","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"3 Guix 介绍 Guix/Nix的机制可以很好的解决依赖问题. 他们的软件实际在一个用sha256和文件名做区分的store里, 然后symlink出来一个软件包的集合(叫profile), 这样相同软件的不同版本可以很简单的互存. 那么他们的原理是什么呢? ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:3:0","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"3.1 GNU 项目与 linux 在介绍 Guix 之前, 我需要先介绍一些 Guix 的历史背景, 因为这些背景可以帮助我们理解 Guix 系统的特点和设计理念. Richard Matthew Stallman(RMS)在1983年9月27日公开发起了GNU 计划，它的目标是创建一套完全自由的操作系统, 后来又创立了自由软件基金会（Free Software Foundation）来为GNU计划提供技术、法律以及财政支持. RMS 为GNU 计划写的第一个产物便是著名的GCC 编译器. 接着又开发出了 emacs 和大部分 UNIX 系统的程序库, 并提出了 GPL 协议, 到1990 年, 唯一依然没有完成的重要组件, 就是操作系统的内核. 1991年, Linus编写出了与UNIX兼容的Linux操作系统内核并在GPL条款下发布. 1992年，Linux与其他GNU软件结合, 大家熟悉的\"GNU/Linux\" 或简称Linux 诞生了。 但 Linux 包含了许多非自由的成分( 比如驱动等 ), 因此GNU 项目一直在试图推出一个完整的自由系统. Guix 便是这种初衷下的产物, 这也意味着 Guix 是 百分之百自由 的. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:3:1","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"3.2 函数与可复现 Guix/Nix 提供了一个函数式语言来描述软件包, 每一个软件包是一个表达式. 进一步地: 表达式可以求值, 那么求值结果可以看做一个软件包, 值不同则代表包不同. 如果更改包的版本, 依赖等, 则会改变表达式的值, 那么就得到了不同的包. 比如 libaaa1.2 和 libaaa1.3 虽然是同一个包的不同版本, 但通过表达式的方案, 会被看做两个不同的包. 有了这两点, 系统上可以派生出很多不同版本的 libaaa, 其他的包可以依赖不同的 libaaa, 因为这些 libaaa 在表达式的层面是不同的包, 因此可以共存. 这种方法还带来了一个优点, 就是干净, 比如一个 hello 的package (use-modules (guix) (guix build-system gnu) (guix licenses)) (package (name \"hello\") (version \"2.10\") (source (origin (method url-fetch) (uri (string-append \"mirror://gnu/hello/hello-\" version \".tar.gz\")) (sha256 (base32 \"0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i\")))) (build-system gnu-build-system) (synopsis \"Hello, GNU world: An example GNU package\") (description \"Guess what GNU Hello prints!\") (home-page \"http://www.gnu.org/software/hello/\") (license gpl3+)) 描述了所需要的所有信息. 系统每次启动只会读取这些表达式, 因此不管你手动安装了多少包, 只要你没有修改 config 文件, 再进入系统都只有这些 config 里表达式的包. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:3:2","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"3.3 Guix 优点 相比其他 linux distro, guix 有以下优点: 函数式声明的方案从根本上彻底解决了依赖问题. 整个系统就是一个声明式的系统, 只要备份好 configuration, 就可以随时拷贝配置文件在新设备上生成一个一样的系统, 因此强大的可复现性和统一性. 原子级的系统回滚和控制. 如果更新遇到了任何问题, 总是可以执行原子级的快速回退, 这带来了强大的系统稳定新, 并节省大量时间 完全可编程的系统. 对整个系统进行编程并处于版本控制之下, 这些都很容易做到. 使用Scheme, 1975 年诞生于 MIT 的语言, 遵循极简主义哲学，以一个小型语言核心作为标准, 简洁强大, 也是我个人非常喜欢的语言. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:3:3","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"3.4 Guix 缺点 正如背景所述, Guix 是一个完全 GPL 协议的系统, 没有 non-free software. 用户在安装时往往需要 手动修改系统内核 并 解决驱动 等问题, 对于新手使用者较为困难. 占用空间较大. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:3:4","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":null,"content":"4 结论 如果对linux 并不熟悉或者是用于部署工业生产环境, 我仍然建议使用 Debain 系或者直接使用 Ubuntu, 生产环境往往长期不变且更新需求小. 如果刚进阶或者希望能够快速进入工作, 我推荐使用 arch, 包罗万象的包管理和强大的wiki 是你最好的帮手. 如果能接受 Guix 的高门槛, 毫无疑问这是一个非常理想的个人操作系统, 完全可控, 稳定, 可复现, 兼容性好, 能够满足日常工作和生活的各种需求. 使用了 Guix 后, 可以把和版本管理相关的包( 比如, python 版本的 conda 或者 virenv 等, 甚至 gcc 的管理等) 都去除, 统一归到系统级别进行处理. ","date":"2022-04-10","objectID":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/:4:0","tags":null,"title":"针对linux 依赖问题的解决方案和个人对 linux distro 的看法","uri":"https://nowislewis.github.io/posts/%E9%92%88%E5%AF%B9linux-%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%92%8C%E4%B8%AA%E4%BA%BA%E5%AF%B9-linux-distro-%E7%9A%84%E7%9C%8B%E6%B3%95/"},{"categories":["emacs"],"content":"1 前言 写代码或者是一些富文本文件时, 经常会遇到这样的场景: 已经写好了一串代码或者文字, 想要方便地给这些东西加上一个符号包括起来, 例如对一个条件判断语句 a==b 加上括号变成 (a==b) , 或者对一段markdown 或 org 文件加上标记. 如果每次都需要手动在开始和结尾的地方加上左括号和右括号, 无疑非常麻烦. ","date":"2022-03-27","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs-%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E7%AE%80%E6%B4%81%E6%96%B9%E6%A1%88%E7%B1%BB%E4%BC%BCvim-surround/:1:0","tags":["hack"],"title":"在emacs 中快速对区域进行符号包裹的简洁方案(类似vim-surround)","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs-%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E7%AE%80%E6%B4%81%E6%96%B9%E6%A1%88%E7%B1%BB%E4%BC%BCvim-surround/"},{"categories":["emacs"],"content":"2 常见方案 vim 给出了 vim-surround 方案, 功能强大但按键稍微繁琐. emacs 的实现方案非常多, 右 paredit, smartparents, parinfer, awesome-pair 等, 它们的功能强大提供了多种对于s-exp 的操作, wrap pair 只是其中的一个非常小的功能, 前两个似乎还存在一些性能问题. 这些包都比较重且我们使用的功能相对较少, 无疑会增大学习成本和个人配置的维护压力. 因此我把目光转向了 emacs 的内置方案. ","date":"2022-03-27","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs-%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E7%AE%80%E6%B4%81%E6%96%B9%E6%A1%88%E7%B1%BB%E4%BC%BCvim-surround/:2:0","tags":["hack"],"title":"在emacs 中快速对区域进行符号包裹的简洁方案(类似vim-surround)","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs-%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E7%AE%80%E6%B4%81%E6%96%B9%E6%A1%88%E7%B1%BB%E4%BC%BCvim-surround/"},{"categories":["emacs"],"content":"3 内置方案与修改 emacs 中有一个 insert-parentheses 的函数, 默认绑定在 \"M-(\" 按键, 可以在一段选定的文字附近添加 “(” 和 “)”, 看起来已经满足我们的部分需求了. 文档如下: (defun insert-parentheses (\u0026optional arg) \"Enclose following ARG sexps in parentheses. Leave point after open-paren. A negative ARG encloses the preceding ARG sexps instead. No argument is equivalent to zero: just insert `()' and leave point between. If `parens-require-spaces' is non-nil, this command also inserts a space before and after, depending on the surrounding characters. If region is active, insert enclosing characters at region boundaries. This command assumes point is not in a string or comment.\" (interactive \"P\") (insert-pair arg ?\\( ?\\))) 仅有一个对于小括号的补全当然不能满足我们的需求, 可以发现, 这个函数的关键在于对 insert-pair 传递的第三和第四个函数, insert-pair 的代码实现较为复杂, 我们这里不多展开, 模仿 insert-parentheses 简单修改便得到如下的函数, 分别对应 ' ', \" \", ` ', * *, [ ], { } 等情况. (defun insert-quotations (\u0026optional arg) \"Enclose following ARG sexps in quotation marks. Leave point after open-paren.\" (interactive \"*P\") (insert-pair arg ?\\' ?\\')) (defun insert-quotes (\u0026optional arg) \"Enclose following ARG sexps in quotes. Leave point after open-quote.\" (interactive \"*P\") (insert-pair arg ?\\\" ?\\\")) (defun insert-backquote (\u0026optional arg) \"Enclose following ARG sexps in quotations with backquote. Leave point after open-quotation.\" (interactive \"*P\") (insert-pair arg ?\\` ?\\')) (defun insert-star (\u0026optional arg) \"Enclose following ARG sexps in stars. Leave point after open-quotation.\" (interactive \"*P\") (insert-pair arg ?\\* ?\\*)) (defun insert-bracket (\u0026optional arg) \"Enclose following ARG sexps in brackets. Leave point after open-quotation.\" (interactive \"*P\") (insert-pair arg ?\\[ ?\\])) (defun insert-curly (\u0026optional arg) \"Enclose following ARG sexps in curly braces. Leave point after open-quotation.\" (interactive \"*P\") (insert-pair arg ?\\{ ?\\})) (defun insert-equate (\u0026optional arg) \"Enclose following ARG sexps in equations. Leave point after open-quotation.\" (interactive \"*P\") (insert-pair arg ?\\= ?\\=)) 然后将这些函数分别绑定到自己喜欢的按键就可以使用了. 当然, 还可以根据需要对上面的函数添加更复杂的符号, 比如 html 的相关标记等. emacs 内置功能简单而强大. ","date":"2022-03-27","objectID":"https://nowislewis.github.io/posts/%E5%9C%A8emacs-%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E7%AE%80%E6%B4%81%E6%96%B9%E6%A1%88%E7%B1%BB%E4%BC%BCvim-surround/:3:0","tags":["hack"],"title":"在emacs 中快速对区域进行符号包裹的简洁方案(类似vim-surround)","uri":"https://nowislewis.github.io/posts/%E5%9C%A8emacs-%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%AF%B9%E5%8C%BA%E5%9F%9F%E8%BF%9B%E8%A1%8C%E7%AC%A6%E5%8F%B7%E5%8C%85%E8%A3%B9%E7%9A%84%E7%AE%80%E6%B4%81%E6%96%B9%E6%A1%88%E7%B1%BB%E4%BC%BCvim-surround/"},{"categories":["life"],"content":"接上篇 毕业个人踩坑指北 – 价值篇 简单谈到了为什么要用时间来衡量生活，本文侧重于帮你理清楚如何衡量一份工作是否值得。 时间是投资储备, 自然可以用来衡量工作。那么是否有更广意义上的薪酬或者回报标准呢? 虽然工作一年比一年卷（似乎好多领域都这样？）, 但也不必太过焦虑, 刚拿到一份offer就匆匆签约。反过来, 这时正是个人状态最好的时候。 此时，心理负担会大为减轻, 若 offer 的分量较重, 同时会减轻其他的面试压力。所以时间不紧张的情况下, 可以继续尝试更多的公司或者面试。 本文并不想侧重如何拿到第一份工作，这跟每个人的情况和喜好都有较大的关联。让我们快进一下，穿越到短期的某个未来, 此时你可能拿到了许多offer，他们也许有优劣之分，也许相差不大。本文想聊的话题，便是若干份工作侧重点不同，难以判断时的一些建议。 粗糙的分析大约有三个标准, 一是 收入 ，二是 行业 ，三是 平衡 （下一篇讲）。其中收入较为直观，行业最重要，平衡是综合考量。 先说结论， 优先考虑时间复利效应好的行业（长久性强的），其次是地域，最后是第一份工作的薪水，生活与工作的平衡程度会等比例放大或缩小效果 。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:0:0","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"1 收入 收入往往是比较关注的一项, 但我更想帮你理清楚收入与别的更重要的事情的关联, 以免陷入唯金钱论的焦虑中。收入有多个维度的考虑： 工作时间，工作强度，金钱收入，行业的沉没成本，生活开支，家人的影响 等等。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:1:0","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"1.1 薪酬 互联网大体状况可以参考这份链接: https://www.zhihu.com/question/429548710 , 出处似乎是交大水源BBS的内部水贴，资料稍微有些过时（去年和今年的待遇都更好一些）。为了真实性，在分析时仅举其中几个我秋招经历过的公司为例，所以作为一份可靠的参考，其他公司可向上向下类推，我经历有限只能给出这些公司的数据。 字节跳动等一众互联网公司。 据我了解秋招大家签的offer都不错, 硕士大部分在一年40~45w左右, 优秀的567开头也很多。博士比比皆是的60打底，但期权已经越来越吝啬, 且有35岁被优化之风险。 外企。以我比较了解的微软为例, 至于亚马逊等其他外企平均差别不大，但值得注意的是不同小组的工作强度可能差别较大，建议事前调查清楚。 白菜23.8w base(即20k)+4w刀股票分四年(即6w股)+3w签字费+10%bonus 。 sp28.4w base(即24k)+5.5w刀股票分四年(即8w股)+3w签字费+10%bonus 。 央企国企，公务员，编制教师等等。这类在江浙地区的收入也不错，且相对轻松稳定。工作年份的影响比较大，有时早入职一年能多拿到很多机会，工作待遇和岗位随着时间的增长收益较高。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:1:1","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"1.2 区间抉择 互联网公司的特点是， 收入的base高 ，人才缺口也大但给的薪水区间也比较大，大佬和摸鱼菜鸡(比如我)都能找到对应的坑位。业务成长快, 工作模块化, 导致 个人晋升压力较大 。比较极端化的例子如某多多, 白菜都到了55+ ，但强度很大，建议你先搜索一下相关新闻再决定是否签约。 微软的情况可以代表一大部分外企以及部分国企, 特点是 收入稍低但相对稳定福利较多 ，有更多的时间和精力提升自己, 以及平衡生活。缺点是 大家水平方差较大 ，参差不齐，自律的大佬晋升飞快, 而摸鱼人可能就把最珍贵的几年用来止步不前了。值得指出的是许多外企都有肉身翻墙的机会（岗位如果在美有对应的职位），可以申请调动，微软平调的话大约一年14~17W美刀，以西雅图的房价是相当舒服。 这两者基本可以代表招人较多的两类大厂的普遍价格。其实还有大量呈现均匀分布的中间带。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:1:2","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"1.3 地域的影响 工作首先会影响的是的生活地点。不像读书时的纯粹，工作后离家距离，生活（住房）成本，通勤成本，城市文化等等都会切切实实参与到你的生活中，需要为你的一切行为负责和买单。 许多人都选择了留在大城市（比如我选择了留在上海）。上海的落户政策相比北京较为友好, 现在许多学校都有直接落户上海的政策，但必须指出的是，“天下没有免费的午餐”，在伴随着薪水高机会多等优点的同时, 也带来了巨大的生活压力。 房贷教育 等多方面都是巨大的开支，不断地推动你往前走。如果你来自小城市，还会面临着和家人的 长期分居 。 而成都南京等城市, 带来的是更多的自由时间，生活成本的降低导致 收入压力 较小 ，带来了更好的生活幸福感，陪伴家人的时间也更多。缺点是 选择面较窄 ，需要看所在的领域在这些城市是否有合适的工作。 总而言之，不能因为城市的大小就贸然决定，因为会在这个城市花费一年乃至更久的时间，这是一份需要细细思考的投资。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:1:3","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"2 行业影响（最重点） ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:2:0","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"2.1 时间角度的复利 由于我并不是会计等相关专业，理解肯定有所片面，这里只能班门弄斧套用概念，不过我相信大家理解含义即可。复利被称为世界第八大奇迹，理解复利概念前，首先区别其和单利的区别。单利是指一笔资金无论存期多长，只有本金计取利息，而以前各期利息在下一个利息周期内不计算利息的计息方法。 而复利简单的理解，是指先计算第一期利息，再加到本金上，然后用新的本金计算下一期的利息，就这样重复计息，来张图直观的看一下： 在基本收益为10, 单次复利为5% 的情况下，复利的影响随着时间呈现指数增长。且复利周期越短，增长速度越快，当周期无限短时，变成了理想的连续复利。 连续复利公式： 时间的影响很容易被忽略掉，一分一秒甚至一天一周的变化都微不可察。但时间又具有持续影响性和颗粒无限细分的特点，所以时间在某种程度上属于 利率很小的连续复利 。 在漫长的时间维度上，某一时刻的高额回报，远不如长期的细小积累。 初期的工作薪酬在时间的影响上十分轻微 。 什么会显著影响到时间的复利性呢？这里想讨论一下行业的影响。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:2:1","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"2.2 为什么行业最重要 第一份工作是正式进入一个行业的标志。进入不同工作或者不同领域，入职的收入差别或者内容差别在该 行业的时间影响力 面前显得 微不足道 。行业抉择是权重最高却恰恰因为信息较少容易忽略的一项。 的确，现在更换工作的机会成本越来越低，甚至许多人的工作都和自己的第一份工作毫不相关。但一年或者几年的黄金工作经验, 在时间的维度可能是当下甚至未来数年最大的一笔 投资 。 同时会显著影响后续的工作抉择空间和生活抉择空间。 应当选择影响时间更为长久的行业或者工作，也就是时间维度上的 复利效应 。例如，教师，航空工作者，科研人员，医生，律师等行业都具备这些优点（还有很多）。 所从事的行业，所花费的时间，都在深刻影响着未来。着重关注行业在时间维度上的正面影响，比如这个领域是否有着足够的抗风险能力，行业是否已经有了良好的发展基础，这些保底因素都会决定着你的经验和履历是否能够随着时间而变得越来越有价值。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:2:2","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"2.3 简短的问题 在茫然而主观地谈论行业地优缺点前，或者开始收集信息前，可以先从如下几个角度进行简短的思考： 是否 喜欢 这个领域？ 是否值得自己 投入几年 的时间？ 工作履历是否能产生 复利效应 ？ 该领域是否有比较好的 个人发展渠道 ？ 行业是否 长期健康 ？ ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:2:3","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"2.4 收集信息再回答 不要简单的从主观去回答这个问题，去 搜集 更多的企业和行业信息。 有趣的是，人在难以抉择和过快抉择的时候，都可能是缺乏足够的信息。难以抉择往往是对于多方事物掌握的信息相差不多，而过快抉择也可能是因为信息较为片面。 相关信息越多，对于事物的分析就客观，其优点和劣势就越为明显，对于行业的理解就越深刻，不仅会影响到你正确地抉择合适地行业，还会对于你的职业规划有着良性的指导。 可以去相关行业的社区提问，去互联网搜索，去询问相关行业的师兄师姐，想办法去咨询有经验的人士，甚至直接去实习。总之，在决定前， 不要再去简单地用薪水比对工作的优劣 ，而去尽可能搜集多的行业动态和行业细则，这应该是最终决定是否签约的 核心因素 。 我自己最后去了一家背景雄厚的芯片初创公司，芯片对我是一个新的领域，的确有很多困难。选择这份工作很大程度上是因为想要尝试难但是未来回报更高的工作，特别是面视官非常诚恳，人格魅力很足，让我相信来到这里是一份很值得的投资。我入职后除了慢慢适应和学习，也经常去看许多芯片公司的新闻和财报，推测行业的动态。目前我仍觉得这是一个有价值的领域也是一份有趣的工作，对于新人的培养用心，留给新人学习的时间和课程都比较多。但坦白的说, 这里的伙食真的不咋的，建议大家提前调研一下心仪单位的伙食，我这里吃了信息不足的亏，饮食和健康是每个人投资的根本，在时间上的影响无可比拟。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:2:4","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"3 平衡（待续） 生活是你的本位, 但不能一直不变; 工作占据了生活的大部分, 但不是全部。 一开始就应该期望着自己能够很好的平衡这两者, 而不是放弃工作去享受生活, 或者一头扎进工作忽视家人。从最初就努力做好平衡, 两边都努力拿稳。 ","date":"2021-09-20","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/:3:0","tags":null,"title":"  毕业个人踩坑指北(二)–\"薪酬与时间的复利\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%BA%8C/"},{"categories":["life"],"content":"1 引言 本篇博客本来四月份就要写的，拖延症加懒癌一直今天才见文。写之前多有犹豫，一是文笔不好，二是因为我本人也仅仅是艰难毕业艰难就业罢了，实在没有资格给别人建议。 今天趁着下班比较早(底层菜鸡无存在感)，一股脑胡乱写了出来，如果我的经验能给你任何的参考。那也算是很值得的了。 我的许多看法都是从《上海交通大学生存手册》获益而来，在此深表感谢，这个小册子于08年由一群交大本科生写就，强烈推荐大家有空的时候读一读。 原作者团队主要属于出国攻读博士群体，在关于如何立志等问题该手册有着更深入的思考，我仅在补充一些关于就业的粗浅见解。且因为我目前从事行业的信息片面性，所以求职经验可能会偏向于计算机方向。 ","date":"2021-09-09","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/:1:0","tags":null,"title":"  毕业个人踩坑指北(一)–\"价值\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/"},{"categories":["life"],"content":"2 最沉重的价值 ","date":"2021-09-09","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/:2:0","tags":null,"title":"  毕业个人踩坑指北(一)–\"价值\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/"},{"categories":["life"],"content":"2.1 时间 找工作，却需要先谈起时间这个听起来很鸡汤的词汇。这是因为在我看来, 它是顶重要的事情，贯彻着读书，工作以及生活，是抉择事物的核心点, 也是我们真正意义上的私人财富. 平常大家都习惯了用金钱的多寡去衡量一样东西的价值，比如美食的花费，衣服的价格，汽车乃至房产的价值等等。但无形的东西很难这样考虑，比如健康，知识，情感和朋友。而我想强调的，便是 用时间作为一种统一的衡量标准 。 ","date":"2021-09-09","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/:2:1","tags":null,"title":"  毕业个人踩坑指北(一)–\"价值\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/"},{"categories":["life"],"content":"2.2 投资 人的时间是一笔投资 ，举个例子： “如果你手上现在有五百万现金，你打算如何投资？也许你会拿这笔钱炒股炒房炒汇炒基金，或者是开公司开厂房倒买倒卖做生意。但我想，我们这样年纪的人，很少有人会认同把那笔钱换成金银珠宝，放到保险箱里存起来。当然了，看近年通货膨胀的架势，把钱存进银行吃到的利息估计还赶不上贬值的速度。” 我们之所以不认同换金银保值的想法，是因为我们知道，拥有这笔财富不应意味着坐吃山空，它们应当蕴含更大的力量，带来更广阔的机遇，在我们的操纵中产生出更为丰盛的回报。 相比于读书的开销乃至生活消费，我们每个人最沉重的财富，其实是青春，是时间。遗憾的是，无论我们做的有没有意义，哪怕什么也不做，时间仍在流逝。 ","date":"2021-09-09","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/:2:2","tags":null,"title":"  毕业个人踩坑指北(一)–\"价值\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/"},{"categories":["life"],"content":"2.3 衡量 那么， 从时间尺度上 去衡量一项事物的价值便显得理所当然了，甚至不会\"通货膨胀\"。一件事对我们影响的时间越长，就意味着这件事的价值越高。 “花同样的功夫，我们应该尽量多做那些对整个人生都产生正面影响的事情，少做对中期的未来产生影响的事情，不做只对近期产生影响的事情，而产生负面影响的事情应当尽可能避免。” 从这个角度讲，花时间刷无聊网页可以给我们带来几十分钟乃至一天的快乐，花时间做有意义的工作能让我们受益几年，而花时间陪伴家人以及健身则能让我们受益终身。 ","date":"2021-09-09","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/:2:3","tags":null,"title":"  毕业个人踩坑指北(一)–\"价值\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/"},{"categories":["life"],"content":"2.4 对等 希望你始终可以不断停下来思考， 当下做的事情是否有过时间上的考量 。 不管参加什么样的工作或者做什么样的研究，首先应当询问自己一个问题: 是否正在以过于低廉的价格出卖自己的时间? ","date":"2021-09-09","objectID":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/:2:4","tags":null,"title":"  毕业个人踩坑指北(一)–\"价值\"篇\n  ","uri":"https://nowislewis.github.io/posts/%E6%AF%95%E4%B8%9A%E4%B8%AA%E4%BA%BA%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8C%97%E4%B8%80/"},{"categories":["emacs"],"content":"1 M1 和 tree-sitter 简介 M1 芯片于2020年11月11日推出，是 Apple 首款专为Mac打造的芯片，拥有格外出色的性能以及令人惊叹的能效表现，也称为 Apple Silicon ，是arm64 架构的个人电脑芯片，在初期通过转译的方式实现了对于X86 结构引用的支持，而在arm 架构的软件上则表现出惊人的能耗比。作为爱好者自然早早入手了一款尝鲜，但因为架构的更换，许多软件都需要做相应的兼容性处理，本文也是这个目的。 tree-sitter 是一个速度很快的语法parser, 支持incremental parsing, error recovery 等功能，属于抽象语法树AST 在编辑器领域的一种应用。 引用官网的一段介绍: Tree-sitter is a parser generator tool and an incremental parsing library. It can build a concrete syntax tree for a source file and efficiently update the syntax tree as the source file is edited. Tree-sitter aims to be: General enough to parse any programming language Fast enough to parse on every keystroke in a text editor Robust enough to provide useful results even in the presence of syntax errors Dependency-free so that the runtime library (which is written in pure C) can be embedded in any application 目前已经支持C/C++ Go 等几十种语言. 但官方给的二进制文件是 x86 的, 因此对于 MacBook 的arm 架构是无法使用的, 需要自己编译。本文尝试给出一个可行的解决方案。 ","date":"2021-08-28","objectID":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/:1:0","tags":null,"title":"如何在Apple Silicon(M1)上编译tree-sitter","uri":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/"},{"categories":["emacs"],"content":"2 环境准备 首先先安装一下 Homebrew 。Homebrew是一款软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能， “The missing package manager for Macos(or Linux)\"。起初在m1 芯片上需要分离环境分别安装 x86 和 arm 架构的homebrew ，经过数个版本的更新，现在已经可以自动处理，使用以下命令即可： /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" tree-sitter 依赖 Rust, npm 等环境, 可通过以下命令安装快速安装: brew install cargo git npm llvm rust 后续的步骤参考了 这个 issue , 但它指出最新的 tree-sitter v0.20存在BUG 问题难以编译成功. 本人测试问题已经解决, 只需稍做修改即可, 因此我们直接选择最新版本: test -d rust-tree-sitter # clone 仓库 git clone https://github.com/tree-sitter/tree-sitter rust-tree-sitter cd rust-tree-sitter \u0026\u0026 git fetch 如果上述步骤都进行后, 当前目录应该是这样: ","date":"2021-08-28","objectID":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/:2:0","tags":null,"title":"如何在Apple Silicon(M1)上编译tree-sitter","uri":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/"},{"categories":["emacs"],"content":"3 开始编译 接着, 切换到 cli 目录: cd cli \u0026\u0026 cargo install --path . 注意 --path 的后面有一个 . . 这里有一个坑, 如果你像我一样设置了用 GNU/gcc 覆盖了 llvm-gcc, 就需要在 .zshrc 里面注释掉这些代码: #alias gcc='gcc-11' #alias cc='gcc-11' #alias g++='g++-11' #alias c++='c++-11' 可以通过 gcc --version 来简单确认现在使用的版本, 结果大概是这样: liuyi@liuyideMacBook-Pro cli % gcc --version Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple clang version 12.0.5 (clang-1205.0.22.9) Target: arm64-apple-darwin20.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin ","date":"2021-08-28","objectID":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/:3:0","tags":null,"title":"如何在Apple Silicon(M1)上编译tree-sitter","uri":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/"},{"categories":["emacs"],"content":"4 语言编译 接下来的步骤涉及编辑器的实现版本, 我使用的是emacs, 涉及到elisp-tree-sitter 项目, 其他编辑器需要去找类似的版本, 步骤大同小异: cd PROJECT_DIR_YOU_USE # 这个替换成你的项目路径 file cor/tsc.dyn.dylib | grep -q arm64 || rm-rf core/tsc-dyn.dylib grep -q LOCAL core/DYN-VERSION || printf LOCAL \u003ecore/DYN-VERSION grep -q DYN-VERSION bin/build \u0026\u0026 sed -q '/DYN-VERSION/d' bin/build \u003ebin/build.tmp \u0026\u0026 mv bin/build.tmp bin/build \u0026\u0026 chmod +x bin/build || : 然后重建 bindings: EMACS=emacs ./bin/setup \u0026\u0026 EMACS=emacs ./bin/build 然后把相关文件添加到项目的启动路径就可以了。 ","date":"2021-08-28","objectID":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/:4:0","tags":null,"title":"如何在Apple Silicon(M1)上编译tree-sitter","uri":"https://nowislewis.github.io/posts/%E5%A6%82%E4%BD%95%E5%9C%A8apple-siliconm1%E4%B8%8A%E7%BC%96%E8%AF%91tree-sitter/"},{"categories":["tools"],"content":"1 起因 随着工作和学习中资料和知识的不断积累, 经常处于“输入多, 输出少”的状态.这种状态不利于对于知识的吸收和消化. 个人偏好网状的学习方案，寻找不同知识的共通性和串联点，在学习和工作中积累了大量的零散笔记，我会尽量以博客的形式对值得分享的内容进一步整合, 希望这种书写方式能够给读者带来启发. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:1:0","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"2 搭建方案权衡 常见的博客搭建方式有很多种，例如在CSDN、博客园等网站上注册账号发表内容，这种方式具有较高的SEO，博主的文章可以很容易被百度搜索等方式获取，阅读量和评论量都会较为可观，但存在大量同类复制问题，低质量甚至无效内容较多.另一种方式是搭建个人网站，依托服务器部署等方式，个人拥有对网站形式和内容的完全掌控力, 但过程较为繁琐且存在维护成本. 本文经过权衡选择第二种方式进行搭建，因为本文的初衷是个人知识体系的整合输出，且隐私性和聚合性也是主要考虑因素.在尝试了大量的现有方案后，最使用成熟的hugo网页生成方案, 托管在个人github pages页面减少维护成本；使用utteranc作为评论方式.接下来本文会对搭建流程及不同方案选择原因进行描述. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:2:0","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"3 最终效果 虽然搭建的流程会较为复杂，但完成后，由于所有的网页生成部分均由action自动完成，因此 每次更新博客都只需要：本地编写内容－－－》git推送到个人仓库 ，大大减轻了网站的维护负担. 格式都由程序自动化统一控制，整齐方便，省去了排版的工夫，个人觉得比写word 之类的要快捷很多，可以专注于内容创作. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:3:0","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4 搭建流程 本文最终采用的搭建流程图如下： 流程图如下: ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:0","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4.1 生成markdown 本文使用org编写，因此需要ox-hugo生成符合hugo要求的文件.如果读者熟悉markdown，可以参考hugo官方的格式要求编写文章，跳过本小节从“github repo”步骤看起. org是一种功能强大的文本格式，依托于emacs可完成笔记撰写和知识管理等多项要求.使用ox-hugo，经过简单的配置即可在指定的路径下生成文件.其中需要设置的参数有如下几个： #+hugo_base_dir，表示输出文件的路径 #+hugo_section, 表示输出文件的类别和父路径，官方推荐为 post 或者 blog ，也可自行设置. 博客的输出分为两种方式，一种是依托于org mode的subtree结构，每个subtree是一个blog.另一种是每个org文件是一个blog.本文采用第一种方式，这种方式需要在每个需要输出的subtree下面显式的注明 EXPORT_FILE_NAME . 在设置完毕后，执行 C-c C-e H A 即可按照subtree的方式输出多个markdown文件. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:1","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4.2 GitHub repo 将最终的html文件托管在github pages上，方便阅读.这里分为两种方式： 本文生成html文件上传； 上传笔记源文件通过github action自动推送到github pages所在repo. 在对两种方式都进行体验的结果上，出于懒癌本文采用了第二种方案. GitHub pages也有两种生成方案，一种是github个人主页，另一种是项目托管主页.本文最开始采用单项目托管的方式，后来在使用loveit主题时存在图片路径不正确的问题，因此迁移到github个人主页的方式进行托管, 因此本文会主要阐述这种方案. 共分为两步： 以github.io为结尾的仓库，该仓库用于存储博客页面，用户无需改动； source仓库，该仓库默认私密，存储原始文档.通过action检测到source仓库中笔记文件的修改后，会自动调用github actions 推送博客网页到github.io仓库，免去了本地生成网页的麻烦. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:2","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4.3 评论系统选择 最初使用gitalk方案搭建评论系统，但存在索取权限过高问题，经过调研，对比了Vline等方案，最终选择utteranc方案.Utteranc相比需要第三方授权的方案，其利用issue的特性使其拥有对评论内容的完全备份性，可以随时迁出，避免了丢失的可能；其次，utteranc只需一次单repo的授权，对权限的要求大幅缩减，保证了安全性. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:3","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"5 遇到的问题及解决方法 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:5:0","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"5.1 无法正常显示图片 一开始使用单项目单page 的方式，但发现在loveit 的主题下无法正常显示图片，因此最终使用了 GitHub.io 的方式搭建，这种方法的缺点是只能拥有这一个地址，且需要另一个 repo 来负责存储 action 的 souce 文件. ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:5:1","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"5.2 导出路径 在迁移的时候，报错了许多问题，其中一个问题是导出路径要设置为 ./public . ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:5:2","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"5.3 搜索问题： 需要同时设置 lunr 和output ，需要显式写在 taml 文件中，在 loveit 的官方文档中指出了默认参数，但不在 taml 中声明的话是无效的。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:5:3","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"6 添加访问量 不蒜子是一个通过仅仅两行代码实现的网页流量计数器 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:6:0","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"6.1 设置使用custom 代码 在 config.toml 中添加如下代码: [params.footer] enable = true custom='' # 在这里添加下面的代码 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:6:1","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"6.2 引入js 脚本: \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:6:2","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"6.3 在页面添加统计代码 分为两种, 一种是 pv , 即记录总访问数; 另一种是 uv , 即单访客点击任意次数均为1 次. \u003cspan id=\"busuanzi_container_site_pv\"\u003e 本站访问量：\u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e \u0026nbsp; \u003cspan id=\"busuanzi_container_site_uv\"\u003e 您是本站第 \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e 位访问者 \u003c/span\u003e ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:6:3","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"6.4 在单页面中添加以下代码 \u003ch5 id=\"wc\" style=\"font-size: 1rem;text-align: center;\"\u003e{{ .FuzzyWordCount }} Words|Read in about {{ .ReadingTime }} Min|本文总阅读量\u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e次\u003c/h5\u003e 可根据个人喜好选择放在文章头部或尾部 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:6:4","tags":null,"title":"新博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"}]