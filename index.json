[{"categories":null,"content":"1类相关的技术细节 C++ 提供了大量的内置类型( 编译器无须借助程序员在源码中提供的任何声明, 就知道如何表示这种类型的对象以及如何对它进行运算) . 而非内置的类型成为用户自定义类型, 用户自定义类型包括C++ 标准提供的标准库内心和我们自己创建的类型, 值得注意的是, 标准库的开发者并没有什么特权或者语言工具是我们不具备的. 之所以要创建我们的类型, 是因为内置类型的用途有时不够直接, 而通过类型可以更有效的表达我们的思想, 提高效率. 通常来讲, 类型的帮助体现在两个方面: 表示: 一个类型知道如何表示对象中的数据. 运算: 一个类型知道可以对对象进行什么运算. C++ 提供了两种用户自定义类型: 类和枚举. ","date":"2021-07-04","objectID":"https://nowislewis.github.io/posts/%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/:1:0","tags":["cpp"],"title":"类的简单笔记","uri":"https://nowislewis.github.io/posts/%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"1.1类和成员 class X{ public: int m; // 数据成员 int mf(int v){ int old=m; return old;} // 函数成员 } X var; var.m=7; int x=var.mf(9); 成员函数可以直接使用成员名字, 而无须指定前缀, 但如果在外部使用, 则需要指明对象. 1.1.1接口和对象 通常把类看做接口( 类的用户视图 )加上实现( 类的实现者视图 ). 通常接口是\"public\"的, 方便外界访问, 而实现对用户隐藏, 是\"private\" 的. 类成员默认是私有的. 这样, 往往让用户通过公共接口来访问私有成员. 如果类只包含数据成员的话, 用结构体会更高效. 1.1.2构造函数 通常, 我们会设计一些辅助函数, 来完成一些常见操作, 这样就不比重复相同的代码, 还能避免一些同样的错误. 特别是如果某些成员没有进行初始化就被访问, 往往会带来严重的错误, 该错误甚至会难以排查. 因此, 需要不会被程序员忘记的初始化操作, 以及被忽视的可能性很低的操作, C++ 提供了构造函数帮助我们完成这些工作. 构造函数是和类同名的成员函数, 如果一个类具有需要参数的构造函数, 而程序员忘记利用它来初始化, 该错误就会被编译器捕捉. 初始化语法有很多钟, 这里给出最简洁和最啰嗦的: Class_name taday{2000,12,3}; Clase_name christmas=Class_name{2000,12,3}; 在C++98 钟, 人们使用() 来初始化, 但现在倾向于使用{} 来标记初始化列表, 因为可以很清晰的表明初始化过程何时完成, 还能用于内置类型的初始化. 1.1.3保持细节私有 对象的值通常被称为状态, 保持对象的合法值即为维护对象的合法状态. 通常我们会把对象的数据信息私有化, 使得用户不能直接修改成员变量, 而暴露出一些公有的成员函数用于查询私有的成员变量, 这样的好处是避免用户的直接赋值破坏了合法状态. 用户调用成员函数对变量赋值时, 会经过一些判断, 因此就有效的维护了对象的合法性. 这种判定合法值的规则是不变式(invariant). 1.1.4定义成员函数 首先需要指出的是, 编译器并不关注类函数和数据成员的顺序, 因此可以用任意顺序声明, 编译器都能找到. 定义有两种方式, 一种是声明时就定义, 称为类内定义, 另一种是在类外定义. 直接在类定义中定义成员函数有一个优点: 小函数会成为内联的, 编译器为此函数生成调用代码时, 不会生成真正的函数调用, 而是直接将代码嵌入调用者的代码中, 因此会带来较大的性能提升. 但有两个缺点: 每当我们对内联函数体进行修改时, 所有使用这个类的程序都需要重新编译. 而如果在类外声明, 则只有在类接口改变时才会重新编译. 类声明可读性变差. 5 行以上的代码不会从内联中收益, 因此: *除非明确需要从小函数获得性能提升, 否则不要把成员函数在类声明中定义. ","date":"2021-07-04","objectID":"https://nowislewis.github.io/posts/%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/:1:1","tags":["cpp"],"title":"类的简单笔记","uri":"https://nowislewis.github.io/posts/%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"1.2枚举类型 在任何需要一组相关的命名常量的地方都可以使用枚举类型. 枚举指定一个值的集合, 这些值使用符号常量表示, 成为枚举量. enum class Month{ jan=1,feb,mar,apr }; enum class 中的class 表示枚举量在枚举作用域内, 因此必须用 Month::jan 才能访问 jan. 这种方式成为作用域枚举, 是C++ 11 的功能. 还有一种平坦枚举: enum Month{ jan=1,feb,mar,apr }; 在外部可以直接调用 jan. 平坦枚举没有作用域枚举严格, 平坦枚举的枚举量会\" 污染 \" 枚举类型所在的作用域. 枚举的优点是它能够帮助用户把一系列相关的量关联起来, 同时会自动为其他常量赋予基于用户给定或者0 的初值, 增强数据的表示力. ","date":"2021-07-04","objectID":"https://nowislewis.github.io/posts/%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/:1:2","tags":["cpp"],"title":"类的简单笔记","uri":"https://nowislewis.github.io/posts/%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0/"},{"categories":["tools"],"content":"1起因 随着工作和学习中资料和知识的不断积累, 经常处于“输入多, 输出少”的状态。这种状态不利于对于知识的吸收和消化。在费曼学习法中指出,“教会别人”是一种高效的学习方式，因此本文希望能通过自己对于原始知识的反哺, 既帮助了有需要的读者, 也能进一步提升对于知识的理解力。 个人偏好网状的学习方案，寻找不同知识的共通性和串联点，在学习和工作中积累了大量的零散笔记，我会尽量以博客的形式对值得分享的内容进一步整合, 希望这种书写方式能够给读者带来启发。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:1:0","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"2搭建方案权衡 常见的博客搭建方式有很多种，例如在CSDN、博客园等网站上注册账号发表内容，这种方式具有较高的SEO，博主的文章可以很容易被百度搜索等方式获取，阅读量和评论量都会较为可观，但存在大量同类复制问题，低质量甚至无效内容较多。另一种方式是搭建个人网站，依托服务器部署等方式，个人拥有对网站形式和内容的完全掌控力, 但过程较为繁琐且存在维护成本。 本文经过权衡选择第二种方式进行搭建，因为本文的初衷是个人知识体系的整合输出，且隐私性和聚合性也是主要考虑因素。在尝试了大量的现有方案后，最使用成熟的hugo网页生成方案, 托管在个人github pages页面减少维护成本；使用utteranc作为评论方式。接下来本文会对搭建流程及不同方案选择原因进行描述。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:2:0","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"3搭建流程 本文最终采用的搭建流程图如下： 流程图如下: flowchart LR a[emacs]-- org --\u003eb[ox-hugo]-- markdown --\u003ec[github repo] --\u003e d[actions] -- html --\u003ee[website] h[hugo] -. toml .- c d -.- workflow ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:3:0","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"3.1生成markdown 本文使用org编写，因此需要ox-hugo生成符合hugo要求的文件。如果读者熟悉markdown，可以参考hugo官方的格式要求编写文章，跳过本小节从“github repo”步骤看起。 org是一种功能强大的文本格式，依托于emacs可完成笔记撰写和知识管理等多项要求。使用ox-hugo，经过简单的配置即可在指定的路径下生成文件。其中需要设置的参数有如下几个： #+hugo_base_dir，表示输出文件的路径 #+hugo_section, 表示输出文件的类别和父路径，官方推荐为 post 或者 blog ，也可自行设置。 博客的输出分为两种方式，一种是依托于org mode的subtree结构，每个subtree是一个blog。另一种是每个org文件是一个blog。本文采用第一种方式，这种方式需要在每个需要输出的subtree下面显式的注明 EXPORT_FILE_NAME 。 在设置完毕后，执行 C-c C-e H A 即可按照subtree的方式输出多个markdown文件。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:3:1","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"3.2GitHub repo 本文将最终的html文件托管在github pages上，方便阅读。这里分为两种方式： 本文生成html文件上传； 上传笔记源文件通过github action自动推送到github pages所在repo。 在对两种方式都进行体验的结果上，出于懒癌本文采用了第二种方案。 GitHub pages也有两种生成方案，一种是github个人主页，另一种是项目托管主页。本文最开始采用单项目托管的方式，后来在使用loveit主题时存在图片路径不正确的问题，因此迁移到github个人主页的方式进行托管, 因此本文会主要阐述这种方案。 flowchart LR a[安装hugo] --\u003eb[生成本地站点] --\u003ec[设置主题]--\u003ed[上传仓库] --\u003e e[action] 共分为两步： 以github.io为结尾的仓库，该仓库用于存储博客页面，用户无需改动； source仓库，该仓库默认私密，存储原始文档。通过action检测到source仓库中笔记文件的修改后，会自动调用github actions 推送博客网页到github.io仓库，免去了本地生成网页的麻烦。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:3:2","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"3.3评论系统选择 本站最初使用gitalk方案搭建评论系统，但存在索取权限过高问题，经过调研，对比了Vline等方案，最终选择utteranc方案。Utteranc相比需要第三方授权的方案，其利用issue的特性使其拥有对评论内容的完全备份性，可以随时迁出，避免了丢失的可能；其次，utteranc只需一次单repo的授权，对权限的要求大幅缩减，保证了安全性。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:3:3","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4遇到的问题及解决方法 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:0","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4.1无法正常显示图片 本文最开始使用单项目单page 的方式，但发现在loveit 的主题下无法正常显示图片，因此最终使用了 GitHub.io 的方式搭建，这种方法的缺点是只能拥有这一个地址，且需要另一个 repo 来负责存储 action 的 souce 文件。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:1","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4.2导出路径 本文在迁移的时候，报错了许多问题，其中一个问题可能是导出路径要设置为 ./public 。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:2","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"},{"categories":["tools"],"content":"4.3搜索问题： 需要同时设置 lunr 和output ，需要显式写在 taml 文件中，在 loveit 的官方文档中指出了默认参数，但不在 taml 中声明的话是无效的。 ","date":"2021-05-26","objectID":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/:4:3","tags":null,"title":"博客的搭建结构","uri":"https://nowislewis.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E7%BB%93%E6%9E%84/"}]